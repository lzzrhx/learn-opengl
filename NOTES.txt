///////////////////////////////////////////////////////////////////////////////
// This document contains notes for the course:
// "Learn OpenGL" by Joey de Vries
// https://learnopengl.com/
///////////////////////////////////////////////////////////////////////////////

 SECTIONS:
   #1: COURSE OVERVIEW
   #2: LINKS
   #3: NOTES



  #1 | COURSE OVERVIEW:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   [X]  1: Getting started
     [X]  1.1:  OpenGL
     [X]  1.2:  Creating a window
     [X]  1.3:  Hello Window
     [X]  1.4:  Hello Triangle
     [X]  1.5:  Shaders
     [X]  1.6:  Textures
     [X]  1.7:  Transformations
     [X]  1.8:  Coordinate Systems
     [X]  1.9:  Camera
     [X]  1.10: Review
   [X]  2: Lighting
     [X]  2.1:  Colors
     [X]  2.2:  Basic Lighting
     [X]  2.3:  Materials
     [X]  2.4:  Lighting maps
     [X]  2.5:  Light casters
     [X]  2.6:  Multiple lights
     [X]  2.7:  Review
   [X]  3: Model Loading
     [X]  3.1:  Assimp
     [X]  3.2:  Mesh
     [X]  3.3:  Model
   [X]  4: Advanced OpenGL
     [X]  4.1:  Depth testing
     [X]  4.2:  Stencil testing
     [X]  4.3:  Blending
     [X]  4.4:  Face culling
     [X]  4.5:  Framebuffers
     [X]  4.6:  Cubnemaps
     [X]  4.7:  Advanced Data
     [X]  4.8:  Advanced GLSL
     [X]  4.9:  Geometry Shader
     [X]  4.10: Instancing
     [X]  4.11: Anti Aliasing
   [-]  5: Advanced Lighting
     [X]  5.1:  Advanced Lighting
     [X]  5.2:  Gamma Correction
     [X]  5.3:  Shadows
     [-]  5.4:  Normal Mapping
     [-]  5.5:  Parallax Mapping
     [-]  5.6:  HDR
     [-]  5.7:  Bloom
     [-]  5.8:  Deferred Shading
     [-]  5.9:  SSAO
   [-]  6: PBR
     [-]  6.1:  Theory
     [-]  6.2:  Lighting
     [-]  6.3:  IBL
   [-]  7: In Practice
     [X]  7.1:  Debugging
     [-]  7.2:  Text Rendering
     [-]  7.3:  2D Game
   [-]  8: Guest Articles
     [-]  8.1:  OIT
     [-]  8.2:  Skeletal Animation
     [-]  8.3:  CSM
     [-]  8.4:  Scene
     [-]  8.5:  Tessellation
     [-]  8.6:  DSA
     [X]  8.7:  Compute Shaders
     [-]  8.8:  Phys. Based Bloom
     [-]  8.9:  Area Lights

   [X] COMPLETED / [-] NOT COMPLETED



  #2 | LINKS:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

- Learn OpenGL:
  + Website: https://learnopengl.com/
  + PDF:     https://learnopengl.com/book/book_pdf.pdf
  + Print:   https://www.amazon.co.uk/dp/9090332561
  + Repo:    https://github.com/JoeyDeVries/LearnOpenGL

- Documentation:
  + GLFW Documentation - https://www.glfw.org/docs/latest/
  + OpenGL Documentation - https://docs.gl/

- Videos:
  + Graphics Programming - https://www.youtube.com/playlist?list=PLUznfNKscdcO_CqskY66YaXqARepJwanV
  + 3Blue1Brown, Essence of linear algebra - https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab
  + OpenGL Course, Create 3D and 2D Graphics With C++ - https://youtu.be/45MIykWJ-C4
  + Jamie King, 3D Computer Graphics Using OpenGL - https://www.youtube.com/playlist?list=PLRwVmtr-pp06qT6ckboaOhnm9FxmzHpbY
  + The Cherno, OpenGL - https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2

- Books (online and free):
  + Physically Based Rendering: From Theory to Implementation - https://pbr-book.org/4ed/contents
  + Ray Tracing in One Weekend - https://raytracing.github.io/
  + 3D Math Primer for Graphics and Game Development - https://gamemath.com/book/

- GPU Gems:
  + https://developer.nvidia.com/gpugems/gpugems/
  + https://developer.nvidia.com/gpugems/gpugems2/
  + https://developer.nvidia.com/gpugems/gpugems3/

- Math:
  + Matrix multiplication visualizer - http://matrixmultiplication.xyz/
  + Immersive Math - https://immersivemath.com/

- Articles:
  + The Eras of GPU Development - https://blog.siggraph.org/2025/04/evolution-of-gpus.html/
  + What is a color space? - https://www.makingsoftware.com/chapters/color-spaces-models-and-gamuts
  + The DDA Algorithm, explained interactively - https://aaaa.sh/creatures/dda-algorithm-interactive/

- Tips / techniques:
  + Full screen triangle optimization - https://30fps.net/pages/twotris/
  + A series of tricks and techniques I learned doing tiny GLSL demos - https://blog.pkh.me/p/48-a-series-of-tricks-and-techniques-i-learned-doing-tiny-glsl-demos.html

- XOR:
  + Mini: 3D Rotation - https://mini.gmshaders.com/p/3d-rotation
  + Mini: Lights - https://mini.gmshaders.com/p/gm-shaders-mini-lights
  + Noise - https://mini.gmshaders.com/p/gm-shaders-mini-noise-1437243
  + Noise 2 - https://mini.gmshaders.com/p/noise2
  + Functions: Mix - https://mini.gmshaders.com/p/func-mix
  + Decoding: Phosphor - https://mini.gmshaders.com/p/decoding-phosphor

Inigo Quilez:
  + 2D SDFs - https://iquilezles.org/articles/distfunctions2d/
  + 3D SDFs - https://iquilezles.org/articles/distfunctions/
  + 2D SDFs and gradients - https://iquilezles.org/articles/distgradfunctions2d/
  + 3D SDFs and gradients - https://iquilezles.org/articles/distgradfunctions3d/
  + 2D SDF Bounding Boxes - https://iquilezles.org/articles/bboxes2d/
  + 3D SDF Bounding Boxes - https://iquilezles.org/articles/bboxes3d/

- Shadertoy: https://www.shadertoy.com/

- RenderDoc (graphics debugger): https://renderdoc.org/

  #3 | NOTES:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

- Books:
  + Real-Time Rendering
  + Foundations of Game Engine Development
  + Computer Graphics: Principles and Practice
  + Graphics Programming Black Book
  + Understanding the Odin Programming Language

- OpenGL is a right-handed system

- A fragment in OpenGL is all the data required for OpenGL to render a single pixel.

- In modern OpenGL it is required to define at least a custom vertex and fragment shader, since there are no default vertex/fragment shaders on the GPU.

- OpenGL shaders are written in the C-like language GLSL

- Shaders are programs that get some data in, processes it, and outputs some data. The output of a shader is then fed into another shader in the next step in the graphics pipeline.

- OpenGL only processes 3D coordinates when they're in a specific range between -1.0 and 1.0 on all 3 axes. All coordinates within this so called normalized device coordinates range will end up visible on the screen.

- The graphics pipeline (* sections where custom shaders can be injected):
    vertex data[] -> vertex shader* -> geometry shader* -> shape assembly -> rasterization -> fragment shader* -> tests and blending

- Vertex shader: Takes a single vertex as input. Can transform 3D coordinates into different 3D coordinates, and allows for some basic processing on the vertex attributes.

- Geometry shader: The output of the vertex shader is optionally passed to the geometry shader. Takes a collection of vertices that forms a primitive as input. Can generate other shapes by emitting new vertices to fomr new (or other) primitve(s).

- Primitive assembly: Takes all the vertices from the vertex (or geometry) shader that form one or more primitives as input. Assembles all the point(s) in the primitive shape given.

- Rasterization stage: The output of the primitve assembly stage is passed on and the resulting primitive(s) are mapped to the corresponding pixels on the final screen, resulting in framgents for the framgent shader to use. Before the fragment shaders run, clipping is performed, discarding all fragments that are outside the view.

- Fragment shader: Takes the fragments from the rasterizer as input. Calculates the final color of a pixel. Usually the fragment shader contains data about the 3D scene that it can use to calculate the final pixel color (like lights, shadows, color of the light, etc.)

- Alpha test and blending stage: This stage checks the corresponding depth (and stencil) value of the fragment and uses those to check if the resulting fragment is in from or behind other objects and should be discarded accordingly. Alpha values are also checked and objects are blended accordingly.

- In gl.BufferData() there are three options for how to manage the given data:
    + gl.STREAM_DRAW: The data is set only once and used by the GPU at most a few times.
    + gl.STATIC_DRAW: The data is set only once and used many times.
    + gl.DYNAMIC_DRAW: The data is changed a lot and used many times.

- Vertex shader inputs are called vertex attributes, and there are a set maximum number of attributes allowed, limited by the hardware. Some hardware supports more, but OpenGL guarantees that there are always at least 16 4-component vertex attributes available.

- The vertex shader should receive some form of input

- The fragment shader requires a vec4 color output variable

- GLSL data types:
    + Boolean:                   bool
    + Integer:                   int / uint
    + Floating-point number:     float / double
    + Vector (float):            vec2 / vec3 / vec 4

- GLSL vectors:
    + Vector (double):           dvec2 / dvec3 / dvec4
    + Vector (integer):          ivec2 / ivec3 / ivec4
    + Vector (unsigned integer): uvec2 / uvec3 / uvec4
    + Vector (boolean):          bvec2 / bvec3 / bvec4

- 3 ways to access the components of a vector:
    + v.x, v.y, v.z, v.w
    + v.r, v.g, v.r, v.a (used for colors)
    + v.s, v.t, v.p, v.q (used for texture coordinates)

- GLSL supports vector swizzling:
    vec2 someVec;
    vec4 differentVec = someVec.xyxx;
    vec3 anotherVec = differentVec.zyw;
    vec4 otherVec = someVec.xxxx + anotherVec.yxzy;

- Vectors can be passed as arguments to vector constructor calls:
    vec2 vect = vec2(0.5, 0.7);
    vec4 result = vec4(vect, 0.0, 0.0);
    vec4 otherResult = vec4(result.xyz, 1.0);

- Matrix multiplications should be read from right to left. It is adviced to first do scaling operations -> then rotations -> and lastly translations when combining matrices.

- The Gram-Schmidt process can be used to get the camera vector
