///////////////////////////////////////////////////////////////////////////////
// This documents contains notes for:
// Learn OpenGL
// https://learnopengl.com/
///////////////////////////////////////////////////////////////////////////////

 SECTIONS:
   #1: COURSE OVERVIEW
   #2: NOTES



  #1 | COURSE OVERVIEW:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   [-]  1: Getting started
     [X]  1.1:  OpenGL
     [X]  1.2:  Creating a window
     [X]  1.3:  Hello Window
     [X]  1.4:  Hello Triangle
     [X]  1.5:  Shaders
     [X]  1.6:  Textures
     [X]  1.7:  Transformations
     [X]  1.8:  Coordinate Systems
     [-]  1.9:  Camera
     [-]  1.10: Review
   [-]  2: Lighting
     [-]  2.1:  Colors
     [-]  2.2:  Basic Lighting
     [-]  2.3:  Materials
     [-]  2.4:  Lighting maps
     [-]  2.5:  Light casters
     [-]  2.6:  Multiple lights
     [-]  2.7:  Review
   [-]  3: Model Loading
     [-]  3.1:  Assimp
     [-]  3.2:  Mesh
     [-]  3.3:  Model
   [-]  4: Advanced OpenGL
     [-]  4.1:  Depth testing
     [-]  4.2:  Stencil testing
     [-]  4.3:  Blending
     [-]  4.4:  Face culling
     [-]  4.5:  Framebuffers
     [-]  4.6:  Cubnemaps
     [-]  4.7:  Advanced Data
     [-]  4.8:  Advanced GLSL
     [-]  4.9:  Geometry Shader
     [-]  4.10: Instancing
     [-]  4.11: Anti Aliasing
   [-]  5: Advanced Lighting
     [-]  5.1:  Advanced Lighting
     [-]  5.2:  Gamma Correction
     [-]  5.3:  Shadows
       [-]  5.3.1:  Shadow Mapping
       [-]  5.3.2:  Point Shadows
     [-]  5.4:  Normal Mapping
     [-]  5.5:  Parallax Mapping
     [-]  5.6:  HDR
     [-]  5.7:  Bloom
     [-]  5.8:  Deferred Shading
     [-]  5.9:  SSAO
   [-]  6: PBR
     [-]  6.1:  Theory
     [-]  6.2:  Lighting
     [-]  6.3:  IBL
       [-]  6.3.1:  Diffuse irradiance
       [-]  6.3.1:  Specular IBL
   [-]  7: In Practice
   [-]  8: Guest Articles

   [X] COMPLETED / [-] NOT COMPLETED



  #2 | NOTES:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

- Learn OpenGL:
    Website: https://learnopengl.com/
    PDF:     https://learnopengl.com/book/book_pdf.pdf
    Print:   https://www.amazon.co.uk/dp/9090332561

- GLFW Documentation: https://www.glfw.org/docs/latest/

- OpenGL Documentation: https://docs.gl/

- Matrix multiplication visualizer: http://matrixmultiplication.xyz/

- 3Blue1Brown - Essence of linear algebra: https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab

- OpenGL Course - Create 3D and 2D Graphics With C++: https://youtu.be/45MIykWJ-C4

- Jamie King - 3D Computer Graphics Using OpenGL: https://www.youtube.com/playlist?list=PLRwVmtr-pp06qT6ckboaOhnm9FxmzHpbY

- The Cherno - OpenGL: https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2

- OpenGL is a right-handed system

- A fragment in OpenGL is all the data required for OpenGL to render a single pixel.

- In modern OpenGL it is required to define at least a custom vertex and fragment shader, since there are no default vertex/fragment shaders on the GPU.

- OpenGL shaders are written in the C-like language GLSL

- Shaders are programs that get some data in, processes it, and outputs some data. The output of a shader is then fed into another shader in the next step in the graphics pipeline.

- OpenGL only processes 3D coordinates when they're in a specific range between -1.0 and 1.0 on all 3 axes. All coordinates within this so called normalized device coordinates range will end up visible on the screen.

- The graphics pipeline (* sections where custom shaders can be injected):
    vertex data[] -> vertex shader* -> geometry shader* -> shape assembly -> rasterization -> fragment shader* -> tests and blending

- Vertex shader: Takes a single vertex as input. Can transform 3D coordinates into different 3D coordinates, and allows for some basic processing on the vertex attributes.

- Geometry shader: The output of the vertex shader is optionally passed to the geometry shader. Takes a collection of vertices that forms a primitive as input. Can generate other shapes by emitting new vertices to fomr new (or other) primitve(s).

- Primitive assembly: Takes all the vertices from the vertex (or geometry) shader that form one or more primitives as input. Assembles all the point(s) in the primitive shape given.

- Rasterization stage: The output of the primitve assembly stage is passed on and the resulting primitive(s) are mapped to the corresponding pixels on the final screen, resulting in framgents for the framgent shader to use. Before the fragment shaders run, clipping is performed, discarding all fragments that are outside the view.

- Fragment shader: Takes the fragments from the rasterizer as input. Calculates the final color of a pixel. Usually the fragment shader contains data about the 3D scene that it can use to calculate the final pixel color (like lights, shadows, color of the light, etc.)

- Alpha test and blending stage: This stage checks the corresponding depth (and stencil) value of the fragment and uses those to check if the resulting fragment is in from or behind other objects and should be discarded accordingly. Alpha values are also checked and objects are blended accordingly.

- In gl.BufferData() there are three options for how to manage the given data:
    + gl.STREAM_DRAW: The data is set only once and used by the GPU at most a few times.
    + gl.STATIC_DRAW: The data is set only once and used many times.
    + gl.DYNAMIC_DRAW: The data is changed a lot and used many times.

- Vertex shader inputs are called vertex attributes, and there are a set maximum number of attributes allowed, limited by the hardware. Some hardware supports more, but OpenGL guarantees that there are always at least 16 4-component vertex attributes available.

- The vertex shader should receive some form of input

- The fragment shader requires a vec4 color output variable

- GLSL data types:
    + Boolean:                   bool
    + Integer:                   int / uint
    + Floating-point number:     float / double
    + Vector (float):            vec2 / vec3 / vec 4

- GLSL vectors:
    + Vector (double):           dvec2 / dvec3 / dvec4
    + Vector (integer):          ivec2 / ivec3 / ivec4
    + Vector (unsigned integer): uvec2 / uvec3 / uvec4
    + Vector (boolean):          bvec2 / bvec3 / bvec4

- 3 ways to access the components of a vector:
    + v.x, v.y, v.z, v.w
    + v.r, v.g, v.r, v.a (used for colors)
    + v.s, v.t, v.p, v.q (used for texture coordinates)

- GLSL supports vector swizzling:
    vec2 someVec;
    vec4 differentVec = someVec.xyxx;
    vec3 anotherVec = differentVec.zyw;
    vec4 otherVec = someVec.xxxx + anotherVec.yxzy;

- Vectors can be passed as arguments to vector constructor calls:
    vec2 vect = vec2(0.5, 0.7);
    vec4 result = vec4(vect, 0.0, 0.0);
    vec4 otherResult = vec4(result.xyz, 1.0);

- Matrix multiplications should be read from right to left. It is adviced to first do scaling operations -> then rotations -> and lastly translations when combining matrices.
